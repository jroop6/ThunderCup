package Classes.Animation;

import javafx.geometry.Point2D;
import javafx.geometry.Rectangle2D;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.image.Image;
import javafx.scene.transform.Affine;

import java.io.*;
import java.util.ArrayList;
import java.util.List;

/**
 * A class for handling spritesheets. Includes methods for reading spritesheets and their metadata from disk and drawing
 * a specific frame on a given GraphicsContext. Each frame has its own "anchor point". When the program wishes to
 * display a frame from the spritesheet, it passes the desired location of the anchor point to the drawFrame method.
 * This allows for the frame bounds to change in size (for example, if a character is swinging his/her arms while
 * walking, the frames may change in width) while still carefully controlling the position of the character to avoid
 * jitter.
 */
public class SpriteSheet extends Image {

    private List<FrameBound> frameBounds = new ArrayList<>(); // Note: FrameBound is an inner class. Find it below.

    /**
     * Constructor used for spritesheets whose frames have variable sizes. The sprite sheet image file must be
     * accompanied by a metadata file describing the positions, dimensions, and anchor point locations of each sprite
     * image. Such a metadata file can be auto-generated by using the Sprite Sheet Creator Utility program on a given
     * image sequence.
     * @param spriteSheetURL The image file containing the spritesheet.
     */
    public SpriteSheet(String spriteSheetURL){
        super(spriteSheetURL);
        readSpriteMetadata(spriteSheetURL);
    }

    public void readSpriteMetadata(String spriteSheetURL){
        // Construct the metadata file url from the spritesheet url:
        String metaDataURL = spriteSheetURL.substring(0,spriteSheetURL.length()-15) + "metadata.csv";
        String line;
        try{
            InputStream stream = getClass().getClassLoader().getResourceAsStream(metaDataURL);
            BufferedReader reader = new BufferedReader(new InputStreamReader(stream));

            //BufferedReader reader = new BufferedReader(new InputStreamReader(getClass().getResourceAsStream(metaDataURL)));
            while((line = reader.readLine())!=null){
                String[] args =line.split(",");
                int frameX = Integer.parseInt(args[0]);
                int frameY = Integer.parseInt(args[1]);
                int frameWidth = Integer.parseInt(args[2]);
                int frameHeight = Integer.parseInt(args[3]);
                double anchorX = Double.parseDouble(args[4]);
                double anchorY = Double.parseDouble(args[5]);
                frameBounds.add(new FrameBound(new Rectangle2D(frameX, frameY, frameWidth, frameHeight), new Point2D(anchorX, anchorY)));
            }
        } catch(IOException e){
            e.printStackTrace();
        }
    }

    public int getMaxFrameIndex(){
        return frameBounds.size()-1;
    }

    /**
     * A class for storing the position, dimensions, and anchor point location for a sprite in a Sprite. The
     * location of the anchorpoints are relative to the top-left corner of the sprite.
     */
    public class FrameBound {
        private Rectangle2D posAndDim;
        private Point2D anchorPoint;

        public FrameBound(Rectangle2D posAndDim, Point2D anchorPoint){
            this.posAndDim = posAndDim;
            this.anchorPoint = anchorPoint;
        }

        public Rectangle2D getPosAndDim() {
            return posAndDim;
        }
        public Point2D getAnchorPoint(){
            return anchorPoint;
        }
    }

    // For drawing with Sprites (ImageViews)
    public FrameBound getFrameBound(int index){
        // First, a sanity check:
        if(index >= frameBounds.size()){
            System.err.println("frame index " + index + " exceeds the maximum sprite index in spritesheet "
                    + this + ", which has only " + frameBounds.size() + "sprites. Note: frames are 0-indexed.");
            return new FrameBound(new Rectangle2D(0,0,1,1),new Point2D(0.5,0.5));
        }
        return frameBounds.get(index);
    }

    // todo: I think using the Affine transform introduced some lag. Confirm this, and see whether there's a more efficient way to accomplish scale+rotation+translation.
    // Draws the specified frame to the graphicsContext. By default, the frame is drawn in the top-left corner. To apply
    // translation, rotation, and scale, apply an affine transformation to the graphics context before calling this
    // method. See AnimationData.drawSelf(GraphicsContext) for an example.
    public int drawFrame(GraphicsContext graphicsContext, int frameIndex){
        // First, a sanity check
        if(frameIndex >= frameBounds.size()){
            System.err.println("frame index " + frameIndex + " exceeds the maximum sprite index in spritesheet "
                    + this + ", which has only " + frameBounds.size() + "sprites. Note: frames are 0-indexed.");
            return 1;
        }

        // draw the sprite:
        Rectangle2D spritePosAndDim = frameBounds.get(frameIndex).posAndDim;
        graphicsContext.drawImage(this,
                spritePosAndDim.getMinX(),    // source x
                spritePosAndDim.getMinY(),    // source y
                spritePosAndDim.getWidth(),   // source width
                spritePosAndDim.getHeight(),  // source height
                0,                     // destination x
                0,                     // destination y
                spritePosAndDim.getWidth(),   // destination width
                spritePosAndDim.getHeight()); // destination height

        return 0;
    }
}
